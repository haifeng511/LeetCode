# 链表类题目解法技巧

## 单链表

下面六个技巧都用到的双指针技巧，在单链表中双指针使用十分广泛



### 1、合并两个有序链表

参考LeetCode中的第2题和第21题

**分析：**

题目给了两个有序列表，注意这里的链表是有顺序的，使用链表的时候，只需要按照顺序进行链表循环即可

链表循环可以使用while，判断链表是否为空，不为空，则进行循环

while循环中判断条件，是两条链表都需要走完的情况下，使用||，只需要走完一条链表，用&&

注意：如果只需要走完一条链表，临时的链表节点，需要指向那个非空的链表节点，把剩下的链表走完

**双指针：**

双指针即定义一个链表templist，再定义一个链表result，使result=templist; 即两个链表指向位置是一样的。

接着，在循环时，使用templist.next 指向另外一个链表，之后使templist  = templist.next (改变（或者说移动）templist指向节点，此时，result的指向是不变的，还是原来的位置，最终的result就是最终形成的链表)

**虚拟头节点：**

虚拟头节点，即在定义templist链表时，给一个初始值-1（也可以其他值，例如0），templist = new LinkNode(-1)

最后的结果链表是result.next 而不是result

如果不使用虚拟头节点，那么是在第一次创建节点（有明确的初始值）之后给result 赋值，最终返回的是result

```JavaScript
	if (!templist) {
             // 第一次创建节点
            templist = new ListNode(sum);
            result = templist;
        } else {
            // 创建新节点
            templist.next = new ListNode(sum);
            // templist指向改变，result指向不变，所以最后返回的是result
            templist = templist.next;
        }
```



### 2、合并 `k` 个有序链表

参考LeetCode23题

合并 `k` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 `k` 个节点中的最小节点，接到结果链表上？

这里我们就要用到 [优先级队列（二叉堆）](https://labuladong.gitee.io/algo/2/20/53/) 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 `k` 个节点中的最小节点：



这里暂时不总结



### 3、寻找单链表的倒数第 `k` 个节点

参考LeetCode19题

**分析：**

如果是寻找单链表的第k个节点，只要for 循环k次就可以找到了，如果链表节点总数为n，那么倒数第k个节点，就是寻找第n-k个节点

上方思路的前提是知道节点总数，而一般情况下算法题，只是给了头结点head，代表一个单链表。如果要知道节点总数n,就需要for循环一次链表，然后再使用for循环，找到第n-k个节点，即要找的倒数第k个节点

如何只遍历一次链表，找到倒数第k个节点呢？

假如说，定义一个链表p1，让p1指向头节点，p1走k步，那么p1现在的位置，再走n-k步，就到了链表末尾空指针了

![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.jpeg)

所以，我们要将p1走n-k步利用起来，定义另外一个链表p2, p2指向头节点

![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/2.jpeg)

当p1在k步的位置继续往下走的时候，p2也继续往下走，这样p1到链表尾部空指针处，走了n-k步，p2从头节点，也走了n-k步 这样就得到了倒数第k个节点的位置了

![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/3.jpeg)



**总结：**

利用两个链表p1,p2，p1指向第k个位置，p2指向头结点，两个链表同步往下走，当p1走了n-k步到链表尾部空指针处，p2也走了n-k步，也就是倒数第k个节点的位置



### 4、寻找单链表的中点

参考LeetCode的876题

**分析：**

**常规解法：**

先循环遍历链表，得到单链表的长度n，再进行遍历，找到n/2 个节点的位置，也就是单链表的中点

**优解方法：**

使用双指针方法，这里时双指针中的快慢指针，定义两个链表（fast、slow）都指向头节点，两个链表都往下走，当slow走一步时，fast走两步，那么当fast走到链表的的尾部空指针处，slow也就走到了链表的中点

**注意：**

如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点



### 5、判断单链表是否包含环并找出环起点



**分析：**

这里也使用双指针中的快慢指针，当慢指针走一步，快指针走两步

如果快指针遇到null，说明链表没有环，而当快指针追上慢指针的时候，肯定存在环，此时，慢指针走了k步，快指针走了2k步

![img](https://labuladong.gitee.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/3.jpeg)

快指针多走了 k步，也是快指针在环里转圈圈的的长度，所以这里k步是环的整数倍（第一次的时候是一倍，也就是慢指针走了一圈，快指针走了两圈）

假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。

巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了

![img](https://labuladong.gitee.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。

**总结：**

使用双指针中的快慢指针，当慢指针走一步，快指针走两步。如果快指针遇到null，说明链表没有环，而当快指针追上慢指针的时候，肯定存在环。找起点位置：当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置



### 6、判断两个单链表是否相交并找出交点

参考LeetCode160题

![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/4.png)

例如：A、B两个单链表，我们需要返回的是c1这个节点

**分析：**

**常规解法：**

用 HashSet 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间

**更优解：**

使用两个指针

![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/5.jpeg)

如果只使用两个指针p1、p2，两个指针分别在链表中前进，但是这样，没有办法使得两个指针同时指到c1节点

**解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1**

我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起

如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1

![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg)

如果没有交点，则返回的是空指针null

这样的解法：空间复杂度为 O(1)，时间复杂度为 O(N)

